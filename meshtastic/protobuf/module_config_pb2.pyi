"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _RemoteHardwarePinType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _RemoteHardwarePinTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_RemoteHardwarePinType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN: _RemoteHardwarePinType.ValueType  # 0
    """
    Unset/unused
    """
    DIGITAL_READ: _RemoteHardwarePinType.ValueType  # 1
    """
    GPIO pin can be read (if it is high / low)
    """
    DIGITAL_WRITE: _RemoteHardwarePinType.ValueType  # 2
    """
    GPIO pin can be written to (high / low)
    """

class RemoteHardwarePinType(_RemoteHardwarePinType, metaclass=_RemoteHardwarePinTypeEnumTypeWrapper): ...

UNKNOWN: RemoteHardwarePinType.ValueType  # 0
"""
Unset/unused
"""
DIGITAL_READ: RemoteHardwarePinType.ValueType  # 1
"""
GPIO pin can be read (if it is high / low)
"""
DIGITAL_WRITE: RemoteHardwarePinType.ValueType  # 2
"""
GPIO pin can be written to (high / low)
"""
global___RemoteHardwarePinType = RemoteHardwarePinType

@typing.final
class ModuleConfig(google.protobuf.message.Message):
    """
    Module Config
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class MQTTConfig(google.protobuf.message.Message):
        """
        MQTT Client Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        ADDRESS_FIELD_NUMBER: builtins.int
        USERNAME_FIELD_NUMBER: builtins.int
        PASSWORD_FIELD_NUMBER: builtins.int
        ENCRYPTION_ENABLED_FIELD_NUMBER: builtins.int
        JSON_ENABLED_FIELD_NUMBER: builtins.int
        TLS_ENABLED_FIELD_NUMBER: builtins.int
        ROOT_FIELD_NUMBER: builtins.int
        PROXY_TO_CLIENT_ENABLED_FIELD_NUMBER: builtins.int
        MAP_REPORTING_ENABLED_FIELD_NUMBER: builtins.int
        MAP_REPORT_SETTINGS_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        If a meshtastic node is able to reach the internet it will normally attempt to gateway any channels that are marked as
        is_uplink_enabled or is_downlink_enabled.
        """
        address: builtins.str
        """
        The server to use for our MQTT global message gateway feature.
        If not set, the default server will be used
        """
        username: builtins.str
        """
        MQTT username to use (most useful for a custom MQTT server).
        If using a custom server, this will be honoured even if empty.
        If using the default server, this will only be honoured if set, otherwise the device will use the default username
        """
        password: builtins.str
        """
        MQTT password to use (most useful for a custom MQTT server).
        If using a custom server, this will be honoured even if empty.
        If using the default server, this will only be honoured if set, otherwise the device will use the default password
        """
        encryption_enabled: builtins.bool
        """
        Whether to send encrypted or decrypted packets to MQTT.
        This parameter is only honoured if you also set server
        (the default official mqtt.meshtastic.org server can handle encrypted packets)
        Decrypted packets may be useful for external systems that want to consume meshtastic packets
        """
        json_enabled: builtins.bool
        """
        Whether to send / consume json packets on MQTT
        """
        tls_enabled: builtins.bool
        """
        If true, we attempt to establish a secure connection using TLS
        """
        root: builtins.str
        """
        The root topic to use for MQTT messages. Default is "msh".
        This is useful if you want to use a single MQTT server for multiple meshtastic networks and separate them via ACLs
        """
        proxy_to_client_enabled: builtins.bool
        """
        If true, we can use the connected phone / client to proxy messages to MQTT instead of a direct connection
        """
        map_reporting_enabled: builtins.bool
        """
        If true, we will periodically report unencrypted information about our node to a map via MQTT
        """
        @property
        def map_report_settings(self) -> global___ModuleConfig.MapReportSettings:
            """
            Settings for reporting information about our node to a map via MQTT
            """

        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            address: builtins.str = ...,
            username: builtins.str = ...,
            password: builtins.str = ...,
            encryption_enabled: builtins.bool = ...,
            json_enabled: builtins.bool = ...,
            tls_enabled: builtins.bool = ...,
            root: builtins.str = ...,
            proxy_to_client_enabled: builtins.bool = ...,
            map_reporting_enabled: builtins.bool = ...,
            map_report_settings: global___ModuleConfig.MapReportSettings | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["map_report_settings", b"map_report_settings"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["address", b"address", "enabled", b"enabled", "encryption_enabled", b"encryption_enabled", "json_enabled", b"json_enabled", "map_report_settings", b"map_report_settings", "map_reporting_enabled", b"map_reporting_enabled", "password", b"password", "proxy_to_client_enabled", b"proxy_to_client_enabled", "root", b"root", "tls_enabled", b"tls_enabled", "username", b"username"]) -> None: ...

    @typing.final
    class MapReportSettings(google.protobuf.message.Message):
        """
        Settings for reporting unencrypted information about our node to a map via MQTT
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        PUBLISH_INTERVAL_SECS_FIELD_NUMBER: builtins.int
        POSITION_PRECISION_FIELD_NUMBER: builtins.int
        publish_interval_secs: builtins.int
        """
        How often we should report our info to the map (in seconds)
        """
        position_precision: builtins.int
        """
        Bits of precision for the location sent (default of 32 is full precision).
        """
        def __init__(
            self,
            *,
            publish_interval_secs: builtins.int = ...,
            position_precision: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["position_precision", b"position_precision", "publish_interval_secs", b"publish_interval_secs"]) -> None: ...

    @typing.final
    class RemoteHardwareConfig(google.protobuf.message.Message):
        """
        RemoteHardwareModule Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        ALLOW_UNDEFINED_PIN_ACCESS_FIELD_NUMBER: builtins.int
        AVAILABLE_PINS_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Whether the Module is enabled
        """
        allow_undefined_pin_access: builtins.bool
        """
        Whether the Module allows consumers to read / write to pins not defined in available_pins
        """
        @property
        def available_pins(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___RemoteHardwarePin]:
            """
            Exposes the available pins to the mesh for reading and writing
            """

        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            allow_undefined_pin_access: builtins.bool = ...,
            available_pins: collections.abc.Iterable[global___RemoteHardwarePin] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["allow_undefined_pin_access", b"allow_undefined_pin_access", "available_pins", b"available_pins", "enabled", b"enabled"]) -> None: ...

    @typing.final
    class NeighborInfoConfig(google.protobuf.message.Message):
        """
        NeighborInfoModule Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        UPDATE_INTERVAL_FIELD_NUMBER: builtins.int
        TRANSMIT_OVER_LORA_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Whether the Module is enabled
        """
        update_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        Neighbor Info (minimum is 14400, i.e., 4 hours)
        """
        transmit_over_lora: builtins.bool
        """
        Whether in addition to sending it to MQTT and the PhoneAPI, our NeighborInfo should be transmitted over LoRa.
        Note that this is not available on a channel with default key and name.
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            update_interval: builtins.int = ...,
            transmit_over_lora: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["enabled", b"enabled", "transmit_over_lora", b"transmit_over_lora", "update_interval", b"update_interval"]) -> None: ...

    @typing.final
    class DetectionSensorConfig(google.protobuf.message.Message):
        """
        Detection Sensor Module Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _TriggerType:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _TriggerTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ModuleConfig.DetectionSensorConfig._TriggerType.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            LOGIC_LOW: ModuleConfig.DetectionSensorConfig._TriggerType.ValueType  # 0
            """Event is triggered if pin is low"""
            LOGIC_HIGH: ModuleConfig.DetectionSensorConfig._TriggerType.ValueType  # 1
            """Event is triggered if pin is high"""
            FALLING_EDGE: ModuleConfig.DetectionSensorConfig._TriggerType.ValueType  # 2
            """Event is triggered when pin goes high to low"""
            RISING_EDGE: ModuleConfig.DetectionSensorConfig._TriggerType.ValueType  # 3
            """Event is triggered when pin goes low to high"""
            EITHER_EDGE_ACTIVE_LOW: ModuleConfig.DetectionSensorConfig._TriggerType.ValueType  # 4
            """Event is triggered on every pin state change, low is considered to be
            "active"
            """
            EITHER_EDGE_ACTIVE_HIGH: ModuleConfig.DetectionSensorConfig._TriggerType.ValueType  # 5
            """Event is triggered on every pin state change, high is considered to be
            "active"
            """

        class TriggerType(_TriggerType, metaclass=_TriggerTypeEnumTypeWrapper): ...
        LOGIC_LOW: ModuleConfig.DetectionSensorConfig.TriggerType.ValueType  # 0
        """Event is triggered if pin is low"""
        LOGIC_HIGH: ModuleConfig.DetectionSensorConfig.TriggerType.ValueType  # 1
        """Event is triggered if pin is high"""
        FALLING_EDGE: ModuleConfig.DetectionSensorConfig.TriggerType.ValueType  # 2
        """Event is triggered when pin goes high to low"""
        RISING_EDGE: ModuleConfig.DetectionSensorConfig.TriggerType.ValueType  # 3
        """Event is triggered when pin goes low to high"""
        EITHER_EDGE_ACTIVE_LOW: ModuleConfig.DetectionSensorConfig.TriggerType.ValueType  # 4
        """Event is triggered on every pin state change, low is considered to be
        "active"
        """
        EITHER_EDGE_ACTIVE_HIGH: ModuleConfig.DetectionSensorConfig.TriggerType.ValueType  # 5
        """Event is triggered on every pin state change, high is considered to be
        "active"
        """

        ENABLED_FIELD_NUMBER: builtins.int
        MINIMUM_BROADCAST_SECS_FIELD_NUMBER: builtins.int
        STATE_BROADCAST_SECS_FIELD_NUMBER: builtins.int
        SEND_BELL_FIELD_NUMBER: builtins.int
        NAME_FIELD_NUMBER: builtins.int
        MONITOR_PIN_FIELD_NUMBER: builtins.int
        DETECTION_TRIGGER_TYPE_FIELD_NUMBER: builtins.int
        USE_PULLUP_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Whether the Module is enabled
        """
        minimum_broadcast_secs: builtins.int
        """
        Interval in seconds of how often we can send a message to the mesh when a
        trigger event is detected
        """
        state_broadcast_secs: builtins.int
        """
        Interval in seconds of how often we should send a message to the mesh
        with the current state regardless of trigger events When set to 0, only
        trigger events will be broadcasted Works as a sort of status heartbeat
        for peace of mind
        """
        send_bell: builtins.bool
        """
        Send ASCII bell with alert message
        Useful for triggering ext. notification on bell
        """
        name: builtins.str
        """
        Friendly name used to format message sent to mesh
        Example: A name "Motion" would result in a message "Motion detected"
        Maximum length of 20 characters
        """
        monitor_pin: builtins.int
        """
        GPIO pin to monitor for state changes
        """
        detection_trigger_type: global___ModuleConfig.DetectionSensorConfig.TriggerType.ValueType
        """
        The type of trigger event to be used
        """
        use_pullup: builtins.bool
        """
        Whether or not use INPUT_PULLUP mode for GPIO pin
        Only applicable if the board uses pull-up resistors on the pin
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            minimum_broadcast_secs: builtins.int = ...,
            state_broadcast_secs: builtins.int = ...,
            send_bell: builtins.bool = ...,
            name: builtins.str = ...,
            monitor_pin: builtins.int = ...,
            detection_trigger_type: global___ModuleConfig.DetectionSensorConfig.TriggerType.ValueType = ...,
            use_pullup: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["detection_trigger_type", b"detection_trigger_type", "enabled", b"enabled", "minimum_broadcast_secs", b"minimum_broadcast_secs", "monitor_pin", b"monitor_pin", "name", b"name", "send_bell", b"send_bell", "state_broadcast_secs", b"state_broadcast_secs", "use_pullup", b"use_pullup"]) -> None: ...

    @typing.final
    class AudioConfig(google.protobuf.message.Message):
        """
        Audio Config for codec2 voice
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _Audio_Baud:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _Audio_BaudEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ModuleConfig.AudioConfig._Audio_Baud.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            CODEC2_DEFAULT: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 0
            CODEC2_3200: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 1
            CODEC2_2400: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 2
            CODEC2_1600: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 3
            CODEC2_1400: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 4
            CODEC2_1300: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 5
            CODEC2_1200: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 6
            CODEC2_700: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 7
            CODEC2_700B: ModuleConfig.AudioConfig._Audio_Baud.ValueType  # 8

        class Audio_Baud(_Audio_Baud, metaclass=_Audio_BaudEnumTypeWrapper):
            """
            Baudrate for codec2 voice
            """

        CODEC2_DEFAULT: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 0
        CODEC2_3200: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 1
        CODEC2_2400: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 2
        CODEC2_1600: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 3
        CODEC2_1400: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 4
        CODEC2_1300: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 5
        CODEC2_1200: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 6
        CODEC2_700: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 7
        CODEC2_700B: ModuleConfig.AudioConfig.Audio_Baud.ValueType  # 8

        CODEC2_ENABLED_FIELD_NUMBER: builtins.int
        PTT_PIN_FIELD_NUMBER: builtins.int
        BITRATE_FIELD_NUMBER: builtins.int
        I2S_WS_FIELD_NUMBER: builtins.int
        I2S_SD_FIELD_NUMBER: builtins.int
        I2S_DIN_FIELD_NUMBER: builtins.int
        I2S_SCK_FIELD_NUMBER: builtins.int
        codec2_enabled: builtins.bool
        """
        Whether Audio is enabled
        """
        ptt_pin: builtins.int
        """
        PTT Pin
        """
        bitrate: global___ModuleConfig.AudioConfig.Audio_Baud.ValueType
        """
        The audio sample rate to use for codec2
        """
        i2s_ws: builtins.int
        """
        I2S Word Select
        """
        i2s_sd: builtins.int
        """
        I2S Data IN
        """
        i2s_din: builtins.int
        """
        I2S Data OUT
        """
        i2s_sck: builtins.int
        """
        I2S Clock
        """
        def __init__(
            self,
            *,
            codec2_enabled: builtins.bool = ...,
            ptt_pin: builtins.int = ...,
            bitrate: global___ModuleConfig.AudioConfig.Audio_Baud.ValueType = ...,
            i2s_ws: builtins.int = ...,
            i2s_sd: builtins.int = ...,
            i2s_din: builtins.int = ...,
            i2s_sck: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["bitrate", b"bitrate", "codec2_enabled", b"codec2_enabled", "i2s_din", b"i2s_din", "i2s_sck", b"i2s_sck", "i2s_sd", b"i2s_sd", "i2s_ws", b"i2s_ws", "ptt_pin", b"ptt_pin"]) -> None: ...

    @typing.final
    class PaxcounterConfig(google.protobuf.message.Message):
        """
        Config for the Paxcounter Module
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        PAXCOUNTER_UPDATE_INTERVAL_FIELD_NUMBER: builtins.int
        WIFI_THRESHOLD_FIELD_NUMBER: builtins.int
        BLE_THRESHOLD_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Enable the Paxcounter Module
        """
        paxcounter_update_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        metrics to the mesh
        """
        wifi_threshold: builtins.int
        """
        WiFi RSSI threshold. Defaults to -80
        """
        ble_threshold: builtins.int
        """
        BLE RSSI threshold. Defaults to -80
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            paxcounter_update_interval: builtins.int = ...,
            wifi_threshold: builtins.int = ...,
            ble_threshold: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["ble_threshold", b"ble_threshold", "enabled", b"enabled", "paxcounter_update_interval", b"paxcounter_update_interval", "wifi_threshold", b"wifi_threshold"]) -> None: ...

    @typing.final
    class SerialConfig(google.protobuf.message.Message):
        """
        Serial Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _Serial_Baud:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _Serial_BaudEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ModuleConfig.SerialConfig._Serial_Baud.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            BAUD_DEFAULT: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 0
            BAUD_110: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 1
            BAUD_300: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 2
            BAUD_600: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 3
            BAUD_1200: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 4
            BAUD_2400: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 5
            BAUD_4800: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 6
            BAUD_9600: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 7
            BAUD_19200: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 8
            BAUD_38400: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 9
            BAUD_57600: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 10
            BAUD_115200: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 11
            BAUD_230400: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 12
            BAUD_460800: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 13
            BAUD_576000: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 14
            BAUD_921600: ModuleConfig.SerialConfig._Serial_Baud.ValueType  # 15

        class Serial_Baud(_Serial_Baud, metaclass=_Serial_BaudEnumTypeWrapper):
            """
            TODO: REPLACE
            """

        BAUD_DEFAULT: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 0
        BAUD_110: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 1
        BAUD_300: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 2
        BAUD_600: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 3
        BAUD_1200: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 4
        BAUD_2400: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 5
        BAUD_4800: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 6
        BAUD_9600: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 7
        BAUD_19200: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 8
        BAUD_38400: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 9
        BAUD_57600: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 10
        BAUD_115200: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 11
        BAUD_230400: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 12
        BAUD_460800: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 13
        BAUD_576000: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 14
        BAUD_921600: ModuleConfig.SerialConfig.Serial_Baud.ValueType  # 15

        class _Serial_Mode:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _Serial_ModeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ModuleConfig.SerialConfig._Serial_Mode.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            DEFAULT: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 0
            SIMPLE: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 1
            PROTO: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 2
            TEXTMSG: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 3
            NMEA: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 4
            CALTOPO: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 5
            """NMEA messages specifically tailored for CalTopo"""
            WS85: ModuleConfig.SerialConfig._Serial_Mode.ValueType  # 6
            """Ecowitt WS85 weather station"""

        class Serial_Mode(_Serial_Mode, metaclass=_Serial_ModeEnumTypeWrapper):
            """
            TODO: REPLACE
            """

        DEFAULT: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 0
        SIMPLE: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 1
        PROTO: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 2
        TEXTMSG: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 3
        NMEA: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 4
        CALTOPO: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 5
        """NMEA messages specifically tailored for CalTopo"""
        WS85: ModuleConfig.SerialConfig.Serial_Mode.ValueType  # 6
        """Ecowitt WS85 weather station"""

        ENABLED_FIELD_NUMBER: builtins.int
        ECHO_FIELD_NUMBER: builtins.int
        RXD_FIELD_NUMBER: builtins.int
        TXD_FIELD_NUMBER: builtins.int
        BAUD_FIELD_NUMBER: builtins.int
        TIMEOUT_FIELD_NUMBER: builtins.int
        MODE_FIELD_NUMBER: builtins.int
        OVERRIDE_CONSOLE_SERIAL_PORT_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Preferences for the SerialModule
        """
        echo: builtins.bool
        """
        TODO: REPLACE
        """
        rxd: builtins.int
        """
        RX pin (should match Arduino gpio pin number)
        """
        txd: builtins.int
        """
        TX pin (should match Arduino gpio pin number)
        """
        baud: global___ModuleConfig.SerialConfig.Serial_Baud.ValueType
        """
        Serial baud rate
        """
        timeout: builtins.int
        """
        TODO: REPLACE
        """
        mode: global___ModuleConfig.SerialConfig.Serial_Mode.ValueType
        """
        Mode for serial module operation
        """
        override_console_serial_port: builtins.bool
        """
        Overrides the platform's defacto Serial port instance to use with Serial module config settings
        This is currently only usable in output modes like NMEA / CalTopo and may behave strangely or not work at all in other modes
        Existing logging over the Serial Console will still be present
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            echo: builtins.bool = ...,
            rxd: builtins.int = ...,
            txd: builtins.int = ...,
            baud: global___ModuleConfig.SerialConfig.Serial_Baud.ValueType = ...,
            timeout: builtins.int = ...,
            mode: global___ModuleConfig.SerialConfig.Serial_Mode.ValueType = ...,
            override_console_serial_port: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["baud", b"baud", "echo", b"echo", "enabled", b"enabled", "mode", b"mode", "override_console_serial_port", b"override_console_serial_port", "rxd", b"rxd", "timeout", b"timeout", "txd", b"txd"]) -> None: ...

    @typing.final
    class ExternalNotificationConfig(google.protobuf.message.Message):
        """
        External Notifications Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        OUTPUT_MS_FIELD_NUMBER: builtins.int
        OUTPUT_FIELD_NUMBER: builtins.int
        OUTPUT_VIBRA_FIELD_NUMBER: builtins.int
        OUTPUT_BUZZER_FIELD_NUMBER: builtins.int
        ACTIVE_FIELD_NUMBER: builtins.int
        ALERT_MESSAGE_FIELD_NUMBER: builtins.int
        ALERT_MESSAGE_VIBRA_FIELD_NUMBER: builtins.int
        ALERT_MESSAGE_BUZZER_FIELD_NUMBER: builtins.int
        ALERT_BELL_FIELD_NUMBER: builtins.int
        ALERT_BELL_VIBRA_FIELD_NUMBER: builtins.int
        ALERT_BELL_BUZZER_FIELD_NUMBER: builtins.int
        USE_PWM_FIELD_NUMBER: builtins.int
        NAG_TIMEOUT_FIELD_NUMBER: builtins.int
        USE_I2S_AS_BUZZER_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Enable the ExternalNotificationModule
        """
        output_ms: builtins.int
        """
        When using in On/Off mode, keep the output on for this many
        milliseconds. Default 1000ms (1 second).
        """
        output: builtins.int
        """
        Define the output pin GPIO setting Defaults to
        EXT_NOTIFY_OUT if set for the board.
        In standalone devices this pin should drive the LED to match the UI.
        """
        output_vibra: builtins.int
        """
        Optional: Define a secondary output pin for a vibra motor
        This is used in standalone devices to match the UI.
        """
        output_buzzer: builtins.int
        """
        Optional: Define a tertiary output pin for an active buzzer
        This is used in standalone devices to to match the UI.
        """
        active: builtins.bool
        """
        IF this is true, the 'output' Pin will be pulled active high, false
        means active low.
        """
        alert_message: builtins.bool
        """
        True: Alert when a text message arrives (output)
        """
        alert_message_vibra: builtins.bool
        """
        True: Alert when a text message arrives (output_vibra)
        """
        alert_message_buzzer: builtins.bool
        """
        True: Alert when a text message arrives (output_buzzer)
        """
        alert_bell: builtins.bool
        """
        True: Alert when the bell character is received (output)
        """
        alert_bell_vibra: builtins.bool
        """
        True: Alert when the bell character is received (output_vibra)
        """
        alert_bell_buzzer: builtins.bool
        """
        True: Alert when the bell character is received (output_buzzer)
        """
        use_pwm: builtins.bool
        """
        use a PWM output instead of a simple on/off output. This will ignore
        the 'output', 'output_ms' and 'active' settings and use the
        device.buzzer_gpio instead.
        """
        nag_timeout: builtins.int
        """
        The notification will toggle with 'output_ms' for this time of seconds.
        Default is 0 which means don't repeat at all. 60 would mean blink
        and/or beep for 60 seconds
        """
        use_i2s_as_buzzer: builtins.bool
        """
        When true, enables devices with native I2S audio output to use the RTTTL over speaker like a buzzer
        T-Watch S3 and T-Deck for example have this capability
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            output_ms: builtins.int = ...,
            output: builtins.int = ...,
            output_vibra: builtins.int = ...,
            output_buzzer: builtins.int = ...,
            active: builtins.bool = ...,
            alert_message: builtins.bool = ...,
            alert_message_vibra: builtins.bool = ...,
            alert_message_buzzer: builtins.bool = ...,
            alert_bell: builtins.bool = ...,
            alert_bell_vibra: builtins.bool = ...,
            alert_bell_buzzer: builtins.bool = ...,
            use_pwm: builtins.bool = ...,
            nag_timeout: builtins.int = ...,
            use_i2s_as_buzzer: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["active", b"active", "alert_bell", b"alert_bell", "alert_bell_buzzer", b"alert_bell_buzzer", "alert_bell_vibra", b"alert_bell_vibra", "alert_message", b"alert_message", "alert_message_buzzer", b"alert_message_buzzer", "alert_message_vibra", b"alert_message_vibra", "enabled", b"enabled", "nag_timeout", b"nag_timeout", "output", b"output", "output_buzzer", b"output_buzzer", "output_ms", b"output_ms", "output_vibra", b"output_vibra", "use_i2s_as_buzzer", b"use_i2s_as_buzzer", "use_pwm", b"use_pwm"]) -> None: ...

    @typing.final
    class StoreForwardConfig(google.protobuf.message.Message):
        """
        Store and Forward Module Config
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        HEARTBEAT_FIELD_NUMBER: builtins.int
        RECORDS_FIELD_NUMBER: builtins.int
        HISTORY_RETURN_MAX_FIELD_NUMBER: builtins.int
        HISTORY_RETURN_WINDOW_FIELD_NUMBER: builtins.int
        IS_SERVER_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Enable the Store and Forward Module
        """
        heartbeat: builtins.bool
        """
        TODO: REPLACE
        """
        records: builtins.int
        """
        TODO: REPLACE
        """
        history_return_max: builtins.int
        """
        TODO: REPLACE
        """
        history_return_window: builtins.int
        """
        TODO: REPLACE
        """
        is_server: builtins.bool
        """
        Set to true to let this node act as a server that stores received messages and resends them upon request.
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            heartbeat: builtins.bool = ...,
            records: builtins.int = ...,
            history_return_max: builtins.int = ...,
            history_return_window: builtins.int = ...,
            is_server: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["enabled", b"enabled", "heartbeat", b"heartbeat", "history_return_max", b"history_return_max", "history_return_window", b"history_return_window", "is_server", b"is_server", "records", b"records"]) -> None: ...

    @typing.final
    class RangeTestConfig(google.protobuf.message.Message):
        """
        Preferences for the RangeTestModule
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        ENABLED_FIELD_NUMBER: builtins.int
        SENDER_FIELD_NUMBER: builtins.int
        SAVE_FIELD_NUMBER: builtins.int
        enabled: builtins.bool
        """
        Enable the Range Test Module
        """
        sender: builtins.int
        """
        Send out range test messages from this node
        """
        save: builtins.bool
        """
        Bool value indicating that this node should save a RangeTest.csv file.
        ESP32 Only
        """
        def __init__(
            self,
            *,
            enabled: builtins.bool = ...,
            sender: builtins.int = ...,
            save: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["enabled", b"enabled", "save", b"save", "sender", b"sender"]) -> None: ...

    @typing.final
    class TelemetryConfig(google.protobuf.message.Message):
        """
        Configuration for both device and environment metrics
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        DEVICE_UPDATE_INTERVAL_FIELD_NUMBER: builtins.int
        ENVIRONMENT_UPDATE_INTERVAL_FIELD_NUMBER: builtins.int
        ENVIRONMENT_MEASUREMENT_ENABLED_FIELD_NUMBER: builtins.int
        ENVIRONMENT_SCREEN_ENABLED_FIELD_NUMBER: builtins.int
        ENVIRONMENT_DISPLAY_FAHRENHEIT_FIELD_NUMBER: builtins.int
        AIR_QUALITY_ENABLED_FIELD_NUMBER: builtins.int
        AIR_QUALITY_INTERVAL_FIELD_NUMBER: builtins.int
        POWER_MEASUREMENT_ENABLED_FIELD_NUMBER: builtins.int
        POWER_UPDATE_INTERVAL_FIELD_NUMBER: builtins.int
        POWER_SCREEN_ENABLED_FIELD_NUMBER: builtins.int
        HEALTH_MEASUREMENT_ENABLED_FIELD_NUMBER: builtins.int
        HEALTH_UPDATE_INTERVAL_FIELD_NUMBER: builtins.int
        HEALTH_SCREEN_ENABLED_FIELD_NUMBER: builtins.int
        device_update_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        device metrics to the mesh
        """
        environment_update_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        environment measurements to the mesh
        """
        environment_measurement_enabled: builtins.bool
        """
        Preferences for the Telemetry Module (Environment)
        Enable/Disable the telemetry measurement module measurement collection
        """
        environment_screen_enabled: builtins.bool
        """
        Enable/Disable the telemetry measurement module on-device display
        """
        environment_display_fahrenheit: builtins.bool
        """
        We'll always read the sensor in Celsius, but sometimes we might want to
        display the results in Fahrenheit as a "user preference".
        """
        air_quality_enabled: builtins.bool
        """
        Enable/Disable the air quality metrics
        """
        air_quality_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        air quality metrics to the mesh
        """
        power_measurement_enabled: builtins.bool
        """
        Enable/disable Power metrics
        """
        power_update_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        power metrics to the mesh
        """
        power_screen_enabled: builtins.bool
        """
        Enable/Disable the power measurement module on-device display
        """
        health_measurement_enabled: builtins.bool
        """
        Preferences for the (Health) Telemetry Module
        Enable/Disable the telemetry measurement module measurement collection
        """
        health_update_interval: builtins.int
        """
        Interval in seconds of how often we should try to send our
        health metrics to the mesh
        """
        health_screen_enabled: builtins.bool
        """
        Enable/Disable the health telemetry module on-device display
        """
        def __init__(
            self,
            *,
            device_update_interval: builtins.int = ...,
            environment_update_interval: builtins.int = ...,
            environment_measurement_enabled: builtins.bool = ...,
            environment_screen_enabled: builtins.bool = ...,
            environment_display_fahrenheit: builtins.bool = ...,
            air_quality_enabled: builtins.bool = ...,
            air_quality_interval: builtins.int = ...,
            power_measurement_enabled: builtins.bool = ...,
            power_update_interval: builtins.int = ...,
            power_screen_enabled: builtins.bool = ...,
            health_measurement_enabled: builtins.bool = ...,
            health_update_interval: builtins.int = ...,
            health_screen_enabled: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["air_quality_enabled", b"air_quality_enabled", "air_quality_interval", b"air_quality_interval", "device_update_interval", b"device_update_interval", "environment_display_fahrenheit", b"environment_display_fahrenheit", "environment_measurement_enabled", b"environment_measurement_enabled", "environment_screen_enabled", b"environment_screen_enabled", "environment_update_interval", b"environment_update_interval", "health_measurement_enabled", b"health_measurement_enabled", "health_screen_enabled", b"health_screen_enabled", "health_update_interval", b"health_update_interval", "power_measurement_enabled", b"power_measurement_enabled", "power_screen_enabled", b"power_screen_enabled", "power_update_interval", b"power_update_interval"]) -> None: ...

    @typing.final
    class CannedMessageConfig(google.protobuf.message.Message):
        """
        TODO: REPLACE
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        class _InputEventChar:
            ValueType = typing.NewType("ValueType", builtins.int)
            V: typing_extensions.TypeAlias = ValueType

        class _InputEventCharEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[ModuleConfig.CannedMessageConfig._InputEventChar.ValueType], builtins.type):
            DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
            NONE: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 0
            """
            TODO: REPLACE
            """
            UP: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 17
            """
            TODO: REPLACE
            """
            DOWN: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 18
            """
            TODO: REPLACE
            """
            LEFT: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 19
            """
            TODO: REPLACE
            """
            RIGHT: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 20
            """
            TODO: REPLACE
            """
            SELECT: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 10
            """
            '\\n'
            """
            BACK: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 27
            """
            TODO: REPLACE
            """
            CANCEL: ModuleConfig.CannedMessageConfig._InputEventChar.ValueType  # 24
            """
            TODO: REPLACE
            """

        class InputEventChar(_InputEventChar, metaclass=_InputEventCharEnumTypeWrapper):
            """
            TODO: REPLACE
            """

        NONE: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 0
        """
        TODO: REPLACE
        """
        UP: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 17
        """
        TODO: REPLACE
        """
        DOWN: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 18
        """
        TODO: REPLACE
        """
        LEFT: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 19
        """
        TODO: REPLACE
        """
        RIGHT: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 20
        """
        TODO: REPLACE
        """
        SELECT: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 10
        """
        '\\n'
        """
        BACK: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 27
        """
        TODO: REPLACE
        """
        CANCEL: ModuleConfig.CannedMessageConfig.InputEventChar.ValueType  # 24
        """
        TODO: REPLACE
        """

        ROTARY1_ENABLED_FIELD_NUMBER: builtins.int
        INPUTBROKER_PIN_A_FIELD_NUMBER: builtins.int
        INPUTBROKER_PIN_B_FIELD_NUMBER: builtins.int
        INPUTBROKER_PIN_PRESS_FIELD_NUMBER: builtins.int
        INPUTBROKER_EVENT_CW_FIELD_NUMBER: builtins.int
        INPUTBROKER_EVENT_CCW_FIELD_NUMBER: builtins.int
        INPUTBROKER_EVENT_PRESS_FIELD_NUMBER: builtins.int
        UPDOWN1_ENABLED_FIELD_NUMBER: builtins.int
        ENABLED_FIELD_NUMBER: builtins.int
        ALLOW_INPUT_SOURCE_FIELD_NUMBER: builtins.int
        SEND_BELL_FIELD_NUMBER: builtins.int
        rotary1_enabled: builtins.bool
        """
        Enable the rotary encoder #1. This is a 'dumb' encoder sending pulses on both A and B pins while rotating.
        """
        inputbroker_pin_a: builtins.int
        """
        GPIO pin for rotary encoder A port.
        """
        inputbroker_pin_b: builtins.int
        """
        GPIO pin for rotary encoder B port.
        """
        inputbroker_pin_press: builtins.int
        """
        GPIO pin for rotary encoder Press port.
        """
        inputbroker_event_cw: global___ModuleConfig.CannedMessageConfig.InputEventChar.ValueType
        """
        Generate input event on CW of this kind.
        """
        inputbroker_event_ccw: global___ModuleConfig.CannedMessageConfig.InputEventChar.ValueType
        """
        Generate input event on CCW of this kind.
        """
        inputbroker_event_press: global___ModuleConfig.CannedMessageConfig.InputEventChar.ValueType
        """
        Generate input event on Press of this kind.
        """
        updown1_enabled: builtins.bool
        """
        Enable the Up/Down/Select input device. Can be RAK rotary encoder or 3 buttons. Uses the a/b/press definitions from inputbroker.
        """
        enabled: builtins.bool
        """
        Enable/disable CannedMessageModule.
        """
        allow_input_source: builtins.str
        """
        Input event origin accepted by the canned message module.
        Can be e.g. "rotEnc1", "upDownEnc1", "scanAndSelect", "cardkb", "serialkb", or keyword "_any"
        """
        send_bell: builtins.bool
        """
        CannedMessageModule also sends a bell character with the messages.
        ExternalNotificationModule can benefit from this feature.
        """
        def __init__(
            self,
            *,
            rotary1_enabled: builtins.bool = ...,
            inputbroker_pin_a: builtins.int = ...,
            inputbroker_pin_b: builtins.int = ...,
            inputbroker_pin_press: builtins.int = ...,
            inputbroker_event_cw: global___ModuleConfig.CannedMessageConfig.InputEventChar.ValueType = ...,
            inputbroker_event_ccw: global___ModuleConfig.CannedMessageConfig.InputEventChar.ValueType = ...,
            inputbroker_event_press: global___ModuleConfig.CannedMessageConfig.InputEventChar.ValueType = ...,
            updown1_enabled: builtins.bool = ...,
            enabled: builtins.bool = ...,
            allow_input_source: builtins.str = ...,
            send_bell: builtins.bool = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["allow_input_source", b"allow_input_source", "enabled", b"enabled", "inputbroker_event_ccw", b"inputbroker_event_ccw", "inputbroker_event_cw", b"inputbroker_event_cw", "inputbroker_event_press", b"inputbroker_event_press", "inputbroker_pin_a", b"inputbroker_pin_a", "inputbroker_pin_b", b"inputbroker_pin_b", "inputbroker_pin_press", b"inputbroker_pin_press", "rotary1_enabled", b"rotary1_enabled", "send_bell", b"send_bell", "updown1_enabled", b"updown1_enabled"]) -> None: ...

    @typing.final
    class AmbientLightingConfig(google.protobuf.message.Message):
        """
        Ambient Lighting Module - Settings for control of onboard LEDs to allow users to adjust the brightness levels and respective color levels.
        Initially created for the RAK14001 RGB LED module.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        LED_STATE_FIELD_NUMBER: builtins.int
        CURRENT_FIELD_NUMBER: builtins.int
        RED_FIELD_NUMBER: builtins.int
        GREEN_FIELD_NUMBER: builtins.int
        BLUE_FIELD_NUMBER: builtins.int
        led_state: builtins.bool
        """
        Sets LED to on or off.
        """
        current: builtins.int
        """
        Sets the current for the LED output. Default is 10.
        """
        red: builtins.int
        """
        Sets the red LED level. Values are 0-255.
        """
        green: builtins.int
        """
        Sets the green LED level. Values are 0-255.
        """
        blue: builtins.int
        """
        Sets the blue LED level. Values are 0-255.
        """
        def __init__(
            self,
            *,
            led_state: builtins.bool = ...,
            current: builtins.int = ...,
            red: builtins.int = ...,
            green: builtins.int = ...,
            blue: builtins.int = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["blue", b"blue", "current", b"current", "green", b"green", "led_state", b"led_state", "red", b"red"]) -> None: ...

    MQTT_FIELD_NUMBER: builtins.int
    SERIAL_FIELD_NUMBER: builtins.int
    EXTERNAL_NOTIFICATION_FIELD_NUMBER: builtins.int
    STORE_FORWARD_FIELD_NUMBER: builtins.int
    RANGE_TEST_FIELD_NUMBER: builtins.int
    TELEMETRY_FIELD_NUMBER: builtins.int
    CANNED_MESSAGE_FIELD_NUMBER: builtins.int
    AUDIO_FIELD_NUMBER: builtins.int
    REMOTE_HARDWARE_FIELD_NUMBER: builtins.int
    NEIGHBOR_INFO_FIELD_NUMBER: builtins.int
    AMBIENT_LIGHTING_FIELD_NUMBER: builtins.int
    DETECTION_SENSOR_FIELD_NUMBER: builtins.int
    PAXCOUNTER_FIELD_NUMBER: builtins.int
    @property
    def mqtt(self) -> global___ModuleConfig.MQTTConfig:
        """
        TODO: REPLACE
        """

    @property
    def serial(self) -> global___ModuleConfig.SerialConfig:
        """
        TODO: REPLACE
        """

    @property
    def external_notification(self) -> global___ModuleConfig.ExternalNotificationConfig:
        """
        TODO: REPLACE
        """

    @property
    def store_forward(self) -> global___ModuleConfig.StoreForwardConfig:
        """
        TODO: REPLACE
        """

    @property
    def range_test(self) -> global___ModuleConfig.RangeTestConfig:
        """
        TODO: REPLACE
        """

    @property
    def telemetry(self) -> global___ModuleConfig.TelemetryConfig:
        """
        TODO: REPLACE
        """

    @property
    def canned_message(self) -> global___ModuleConfig.CannedMessageConfig:
        """
        TODO: REPLACE
        """

    @property
    def audio(self) -> global___ModuleConfig.AudioConfig:
        """
        TODO: REPLACE
        """

    @property
    def remote_hardware(self) -> global___ModuleConfig.RemoteHardwareConfig:
        """
        TODO: REPLACE
        """

    @property
    def neighbor_info(self) -> global___ModuleConfig.NeighborInfoConfig:
        """
        TODO: REPLACE
        """

    @property
    def ambient_lighting(self) -> global___ModuleConfig.AmbientLightingConfig:
        """
        TODO: REPLACE
        """

    @property
    def detection_sensor(self) -> global___ModuleConfig.DetectionSensorConfig:
        """
        TODO: REPLACE
        """

    @property
    def paxcounter(self) -> global___ModuleConfig.PaxcounterConfig:
        """
        TODO: REPLACE
        """

    def __init__(
        self,
        *,
        mqtt: global___ModuleConfig.MQTTConfig | None = ...,
        serial: global___ModuleConfig.SerialConfig | None = ...,
        external_notification: global___ModuleConfig.ExternalNotificationConfig | None = ...,
        store_forward: global___ModuleConfig.StoreForwardConfig | None = ...,
        range_test: global___ModuleConfig.RangeTestConfig | None = ...,
        telemetry: global___ModuleConfig.TelemetryConfig | None = ...,
        canned_message: global___ModuleConfig.CannedMessageConfig | None = ...,
        audio: global___ModuleConfig.AudioConfig | None = ...,
        remote_hardware: global___ModuleConfig.RemoteHardwareConfig | None = ...,
        neighbor_info: global___ModuleConfig.NeighborInfoConfig | None = ...,
        ambient_lighting: global___ModuleConfig.AmbientLightingConfig | None = ...,
        detection_sensor: global___ModuleConfig.DetectionSensorConfig | None = ...,
        paxcounter: global___ModuleConfig.PaxcounterConfig | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["ambient_lighting", b"ambient_lighting", "audio", b"audio", "canned_message", b"canned_message", "detection_sensor", b"detection_sensor", "external_notification", b"external_notification", "mqtt", b"mqtt", "neighbor_info", b"neighbor_info", "paxcounter", b"paxcounter", "payload_variant", b"payload_variant", "range_test", b"range_test", "remote_hardware", b"remote_hardware", "serial", b"serial", "store_forward", b"store_forward", "telemetry", b"telemetry"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["ambient_lighting", b"ambient_lighting", "audio", b"audio", "canned_message", b"canned_message", "detection_sensor", b"detection_sensor", "external_notification", b"external_notification", "mqtt", b"mqtt", "neighbor_info", b"neighbor_info", "paxcounter", b"paxcounter", "payload_variant", b"payload_variant", "range_test", b"range_test", "remote_hardware", b"remote_hardware", "serial", b"serial", "store_forward", b"store_forward", "telemetry", b"telemetry"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["payload_variant", b"payload_variant"]) -> typing.Literal["mqtt", "serial", "external_notification", "store_forward", "range_test", "telemetry", "canned_message", "audio", "remote_hardware", "neighbor_info", "ambient_lighting", "detection_sensor", "paxcounter"] | None: ...

global___ModuleConfig = ModuleConfig

@typing.final
class RemoteHardwarePin(google.protobuf.message.Message):
    """
    A GPIO pin definition for remote hardware module
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GPIO_PIN_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    gpio_pin: builtins.int
    """
    GPIO Pin number (must match Arduino)
    """
    name: builtins.str
    """
    Name for the GPIO pin (i.e. Front gate, mailbox, etc)
    """
    type: global___RemoteHardwarePinType.ValueType
    """
    Type of GPIO access available to consumers on the mesh
    """
    def __init__(
        self,
        *,
        gpio_pin: builtins.int = ...,
        name: builtins.str = ...,
        type: global___RemoteHardwarePinType.ValueType = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["gpio_pin", b"gpio_pin", "name", b"name", "type", b"type"]) -> None: ...

global___RemoteHardwarePin = RemoteHardwarePin
